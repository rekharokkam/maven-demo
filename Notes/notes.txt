Maven's funda is convention over configuration

Our project is dependent on a library ex- spring framework. Spring framework might in turn be dependent on other libraries. this is called transitive dependencies
It is possible to mention dependency scoping
POM - Project Object Model

groupId, artifactId and version number together create an address for an artifact

repositories hold all of our artifacts and dependencies

dependencies are the library files that we are dependent on
artifacts are the libraries we have generated, archetypes, plugins

2 types of repositories - Local - on the machine , Remote - we access via some type of protocol
Local repo will take precedence over remote repo when we perform dependency resolution

what is a Plug-in - is a collection of goals

goals are the actions we perform / Methods /Operations on source code.

All the work done in maven is done through plugins and goals.

Maven has life cycle. A life cycle is just a named sequence of events

maven has 3 life cycles - clean, default and site
by far "default" life cycle is most widely used.

First command I ran was "mvn package"

when we run "mvn package" - we are executing maven "default" lifecycle and "package" phase. This phase will create a jar file that contains the contents of our project.
every phase that preceedes the current phase will be run by default
precceding phases - compile and test will be executed.

mvn site // Life cycle - site , phase - site

Base directory is always the folder that contains the pom file.

One pom file can be derived from another pom file. In child pom we can override some of the specifications mentioned in the parent pom.
Every pom inherits from a Super pom much like every class in java inherits from Object class.
How to access this super pom file - navigate to - /Users/ac-rekharokkam/Applications/apache-maven-3.5.0/lib/maven-model-builder-3.5.0.jar . Open the pom-4.0.0.xml file
Other way of accessing the same file is - child pom with super inherited pom - mvn help:effective-pom

Each pom can also inherit from another pom that we built.

When ever we have parent-child relationship first step is to run "mvn install" in the parent directory. what this does is, it will take the parent pom and put it in our local repository.

Maven profiles help us build projects for different environments. Customizing the build for an environment

Activator is a way to look at something like an environment variable see what its value is determine by that value what profile to run. If maven finds the value then it runs per what is 
provided inside the profile element.

Maven projects can be generated using the plug in provided by maven called archetype. They are like templates we can use to build our own project. "mvn archetype:generate".
mvn eclipse:eclipse - is the eclipse plugin that will provide eclipse directory structure. Kind of re-building eclipse structure.
Steps to manually generate is - 1) run "mvn archetype:generate 2) "mvn eclipse:eclipse 3) In eclipse import either maven project OR general existing project. 

search.maven.org - maven central repository to search all the jars/software available for download

dependencies
------------
Once any jar is added as dependent in pom.xml file then the jar is downloaded to - /Users/ac-rekharokkam/.m2/repository. If manually removed from this location then when we run 
"mvn dependency:copy-dependecies" it downloads to the .m2 location again and then to - /Users/ac-rekharokkam/Documents/Rekha/workspace/maven-demo/target location. 
the way dependencies work is - first download the dependencies to .m2 location and then copy to local target dependency folder. When mvn dependency plugin is run then maven checks for the jar
file of specified version in the .m2 location if found then copies the jar file to local target - dependency folder. When a dependency is mentioned in the pom file its only downloaded to .m2 directory
but not to project target directory on when specific goals are run it is copied.


Remote respositories
--------------------
Default repo can be checked by executing the file - mvn help:effective-pom
Additional remote repos can be added by editing the settings.xml at the path - /Users/ac-rekharokkam/Applications/apache-maven-3.5.0/conf/settings.xml.
For changes made refer to the comments <!-- Added by me to test remote repos - Starts here--> in the above file.

Scope
-----
Default scope of a dependency is "compile". "compile" scope is available during build, test and run phases of our project. way to test is mvn compile
Other scopes are - 
	import - normally not at all used
	provided - When the dependency should be provided the JDK or the container we are using. This is available for build and test BUT not for deploy as the container would be providing this.
		Ex - servlet-api jar file. This jar file is needed only for build and test BUT not for packaging as the container in which deployment happens will provide this jar file.
	runtime - this is available only during runtime. Ex- a JDBC provider jar, this jar is not needed for compiling but is needed only for running the app. Not used much. It doesn't hurt
	to add these jars to compile scope.
	system - teacher does not recommend this approach. If we have jars placed in the system file path, then this dependency helps get it. So the risk is if the file paths differ then
	this dependency becomes more rigid
	test - available only for test scope.
	
building - mvn compile, 
packaging - mvn package - jar/war/ear
testing - mvn test


conflict resolution
-------------------
refer to maven-manually-generated project and its dependency on 2 other projects - maven-conflict-example and maven-conflict-example2. Both the conflict projects use - commons-lang3 jar file. 
example2 uses version 3.0 and example uses 3.3.2. Maven is smart to pick the latest 3.3.2. If this is not the desired behavior if the intent is to pick lower version then it needs to be 
mentioned in the pom file. refer to maven-manually-generated pom file.

discovery
---------


Lifecycle
---------
Lifecycle consists of a set of stages / steps / phases as we build our artifact. There are 3 inbuilt lifecycles - default, clean and site. Each Lifecycle has its own phases.
A goal will bind be bound to a lifecycle specific phase. a goal can be thought of as a method on a class.
mvn clean - clean phase of clean lifecycle. Use help plugin to learn a little more about this phase. 
mvn help:describe -Dcmd=clean
mvn help:describe -Dcmd=deploy

argument -Dcmd is only for phases

multiple plugins / goals can be used at the same time - mvn clean install

Lifecycle Phases
----------------
default lifecycle has 23 phases.It is the default lifecycle that will be used the most. All phases below are from default lifecycle. 

Compile - 
compiles the source code within our src/main/java directory.

Test-compile - 
compiles the tests found under src/test/java directory. This cannot be executed on its own.

Test -
Runs unit tests using a suitable framework. These tests should not require the code to be deployed or packaged. By default maven will stop if any of the builds fail. 
But it can be configured to skip the tests. 

Package - 
Take the compiled code and package it in the desired format such as jar, war


Install - 
Takes the package built and installs it in the local repo. 
Any jar file in the dependency section of pom file gets downloaded to .m2 directory. But "_remote.repositories" file is not generated. This file helps maven to decide 
how to link to the dependent pom file for local dependencies.
"mvn install" in the project which provides the dependency should be run. this goal creates the "_remote.repositories" file.
Ex - "mvn install" should be run in both the projects - maven-conflict-example and maven-conflict-example2 for dependencies to be resolved for the project maven-manually-generated.

This phase allows other projects to be dependent on this project.

Deploy -
This pushes our artifact to remote repository like maven central or company specific repo for sharing with other developers and projects.


GOals and PLUGins
-----------------
Goals 	perform tasks. These tasks are run against our project for something to happen. Goals can be compared methods in a class.
Plugin comprises of a bunch of Goals. Plugin is analogous to a class which represents a collection of methods.
syntax to execute a goal on a plugin is - mvn <plugin>:<goal> Ex - mvn compiler:compile.
where these plugins come from - super pom - mvn help:effective-pom

To get more details on the plugin - mvn help:describe -Dplugin=compiler
-Dplugin - this argument is for plugins
Get more help on the compiler goal - mvn compiler:help -Ddetail=true -Dgoal=compile 

mvn help:describe -Dcmd=compiler:compile -Ddetail=true - to get more detailed information on the goal.

There are 2 different ways to set the properties for a plugin

1) Through command like argument - 
run help describe command as above and copy the property to be set.
mvn compiler:compile -Dmaven.compiler.verbose=true

2) Set the property through pom.xml file
One advantage of this approach is that they will be applied when we invoke the plugin goal directly OR when the goal is invoked by a lifecycle phase. This is a better approach.
After setting this property just execute - mvn compile

Custom plugin 
-------------
Navigate to the workspace directory and execute the command -
mvn archetype:generate -DgroupId=com.learning.build -DartifactId=first-custom-plugin -DarchetypeArtifactId=maven-archetype-mojo -DarchetypeGroupId=org.apache.maven.archetypes
after the above command completes, execute - mvn eclipse:eclipse
Then import the new project into the workspace.
mvn install - to make this project available inside the local repo for any other project requiring this plugin.


There are 2 ways to execute this plugin
1) Command line
To test the plugin - in the terminal go to maven-manually-generated project and run the command - mvn com.learning.build:first-custom-plugin:touch 
This will demonstrate how this plugin ran against the maven-manually-generated project. in maven-manually-generated project navigate to target directory and check for touch.txt file.

2) Adding the plugin to maven-manually-generated pom file
add the details to the pom of the plugin and run mvn install to make sure the latest changes are available to other projects.
way to run custom plugin is - navigate to maven-manually-generated project and execute - mvn fCustom:touch

 









